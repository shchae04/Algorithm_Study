package study.boj.graph;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 백준 2775번 - 부녀회장이 될테야
 *
 * 문제: k층 n호에 살려면 아래층(k-1층) 1호부터 n호까지 사람들의 수의 합만큼 데려와야 함
 *       0층 i호에는 i명이 살고 있음
 *       k층 n호에 몇 명이 사는지 구하기
 *
 * 알고리즘: 동적 계획법(Dynamic Programming) - 2차원 배열
 * - 각 층의 각 호수별 거주 인원을 bottom-up 방식으로 계산
 * - 이전 층과 같은 층 이전 호수의 값을 활용하여 누적 합 계산
 *
 * 핵심 아이디어:
 * 1. dp[i][j] = i층 j호의 거주 인원 수
 * 2. 베이스 케이스:
 *    - 0층: dp[0][j] = j + 1 (0층 1호=1명, 2호=2명, 3호=3명, ...)
 *    - 모든 층의 1호: dp[i][0] = 1 (항상 1명)
 * 3. 점화식: dp[i][j] = dp[i][j-1] + dp[i-1][j]
 *    - 현재 층 이전 호까지의 합 + 아래층 같은 호의 인원
 *
 * 점화식 유도 과정 (시각화):
 * ┌─────────────────────────────────────────────────────┐
 * │  예시: 2층 3호에 몇 명이 사는가?                     │
 * │                                                     │
 * │  2층 │  1  │  ?  │  ?  │ ← 구하려는 값           │
 * │  ───────────────────────                           │
 * │  1층 │  1  │  3  │  6  │ ← 아래층 값 필요        │
 * │  ───────────────────────                           │
 * │  0층 │  1  │  2  │  3  │ ← 기본 조건             │
 * │                                                     │
 * │  2층 3호 = 2층 2호 + 1층 3호                       │
 * │         = (2층 1호~2호 합) + (0층 1호~3호 합)      │
 * └─────────────────────────────────────────────────────┘
 *
 * 단계별 계산 과정:
 * ┌──────────────────────────────────────────────────────┐
 * │ 0층(기본):    1    2    3    4   ...                │
 * │              ↓    ↓    ↓    ↓                       │
 * │ 1층 1호 = 1                                         │
 * │ 1층 2호 = 1층1호 + 0층2호 = 1 + 2 = 3              │
 * │ 1층 3호 = 1층2호 + 0층3호 = 3 + 3 = 6              │
 * │ 1층 4호 = 1층3호 + 0층4호 = 6 + 4 = 10             │
 * │                                                      │
 * │ 2층 1호 = 1                                         │
 * │ 2층 2호 = 2층1호 + 1층2호 = 1 + 3 = 4              │
 * │ 2층 3호 = 2층2호 + 1층3호 = 4 + 6 = 10             │
 * │ 2층 4호 = 2층3호 + 1층4호 = 10 + 10 = 20           │
 * │                                                      │
 * │ 패턴: 왼쪽값 + 아래값 = 현재값                      │
 * │       ←─────┐                                       │
 * │             ↓                                       │
 * │       ↑─────[현재]                                  │
 * └──────────────────────────────────────────────────────┘
 *
 * 전체 DP 테이블 (3층 4호까지):
 * ┌─────┬─────┬─────┬─────┬─────┐
 * │ 층\호│  1  │  2  │  3  │  4  │
 * ├─────┼─────┼─────┼─────┼─────┤
 * │  0  │  1  │  2  │  3  │  4  │
 * │  1  │  1  │  3  │  6  │ 10  │
 * │  2  │  1  │  4  │ 10  │ 20  │
 * │  3  │  1  │  5  │ 15  │ 35  │
 * └─────┴─────┴─────┴─────┴─────┘
 *
 * 시간복잡도: O(k * n) - k는 층수, n은 호수
 * - 각 층의 각 호수를 한 번씩 계산
 *
 * 공간복잡도: O(k * n)
 * - 2차원 DP 배열 사용
 */

public class boj2775 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());

        for(int i = 0; i < T; i++) {
            int floor = Integer.parseInt(br.readLine());
            int room = Integer.parseInt(br.readLine());
            System.out.println(dp(floor, room));
            System.out.println(dpTopDown(floor, room));
        }
    }

    /*
     * ========================================
     * 바텀업(Bottom-Up) 방식
     * ========================================
     *
     * [동작 방식]
     * 0층부터 시작하여 위층으로 올라가며 계산
     * 각 층의 1호부터 순서대로 n호까지 계산
     * 이미 계산된 값(왼쪽, 아래)을 참조하여 현재 값 계산
     *
     * [실행 순서 시각화] - 2층 3호 계산 예시
     *
     *   2층  |  7  |  8  |  9  |
     *   1층  |  4  |  5  |  6  |
     *   0층  |  1  |  2  |  3  |  <- 베이스 케이스
     *
     *   계산 순서 (숫자가 작을수록 먼저):
     *   1. 0층 초기화: 1, 2, 3
     *   2. 1층 1호: 1
     *   3. 1층 2호: 1층1호(1) + 0층2호(2) = 3
     *   4. 1층 3호: 1층2호(3) + 0층3호(3) = 6
     *   5. 2층 1호: 1
     *   6. 2층 2호: 2층1호(1) + 1층2호(3) = 4
     *   7. 2층 3호: 2층2호(4) + 1층3호(6) = 10  <- 목표
     *
     *   특징: 왼쪽->오른쪽, 아래->위 순서로 진행
     *
     * [장점]
     * - 반복문 사용으로 스택 오버플로우 위험 없음
     * - 계산 순서가 명확하고 예측 가능
     * - 모든 값을 순차적으로 채워나가므로 직관적
     *
     * [단점]
     * - 필요하지 않은 모든 칸도 계산
     */
    public static int dp(int floor, int room) {
        int[][] arr = new int[floor + 1][room];

        // 베이스 케이스 초기화
        for (int i = 0; i < floor + 1; i++) {
            for (int j = 0; j < room; j++) {
                arr[i][0] = 1;        // 모든 층의 1호는 1명
                arr[0][j] = j + 1;    // 0층은 j+1명
            }
        }

        // 바텀업: 1층 1호부터 순차적으로 계산
        for (int i = 1; i < floor + 1; i++) {
            for (int j = 1; j < room; j++) {
                // 점화식: 왼쪽값 + 아래값
                arr[i][j] = arr[i][j - 1] + arr[i - 1][j];
            }
        }
        return arr[floor][room - 1];
    }

    /*
     * ========================================
     * 탑다운(Top-Down) 방식
     * ========================================
     *
     * [동작 방식]
     * 목표 값(k층 n호)부터 시작하여 필요한 값만 재귀적으로 계산
     * 계산된 값은 메모이제이션하여 중복 계산 방지
     * 베이스 케이스에 도달할 때까지 재귀 호출
     *
     * [재귀 호출 트리 시각화] - 2층 3호 계산 예시
     *
     *                 dp(2,3)  <- 목표
     *                /      \
     *               /        \
     *          dp(2,2)      dp(1,3)
     *           /   \        /    \
     *          /     \      /      \
     *     dp(2,1) dp(1,2) dp(1,2) dp(0,3)
     *       /\      /\     (메모)  (베이스)
     *      ... ... ... ...
     *
     * [호출 순서 예시] - 깊이 우선 탐색(DFS)
     *   1. dp(2,3) 호출 -> 없음, 계산 시작
     *   2. dp(2,2) 필요 -> 재귀 호출
     *   3. dp(2,1) 필요 -> 재귀 호출
     *   4. dp(2,0) 필요 -> 베이스: 1 반환
     *   5. dp(1,1) 필요 -> 재귀 호출
     *   ... (필요한 경로만 탐색)
     *
     * [계산 과정]
     *   dp[2][3] = dp[2][2] + dp[1][3]
     *            = (dp[2][1] + dp[1][2]) + (dp[1][2] + dp[0][3])
     *            = ((1 + 3) + (1 + 2 + 3))
     *            = 4 + 6 = 10
     *
     * [메모이제이션 효과]
     *   dp(1,2)가 여러 번 필요한 경우:
     *   - 첫 호출: dp(1,2) 계산 -> 3 (저장)
     *   - 재호출: dp(1,2) -> 메모에서 3 반환 (재계산 X)
     *   - 계산량: O(k*n) - 각 칸 1번만 계산
     *
     * [장점]
     * - 필요한 값만 계산 (목표까지 가는 경로만)
     * - 점화식을 재귀로 자연스럽게 표현
     * - 문제를 분할하여 해결하는 방식이 직관적
     *
     * [단점]
     * - 재귀 호출 오버헤드 존재
     * - 깊은 재귀로 인한 스택 사용량 증가
     * - 바텀업보다 느릴 수 있음
     */
    static int[][] memo;

    public static int dpTopDown(int floor, int room) {
        memo = new int[floor + 1][room + 1];

        // -1로 초기화 (아직 계산 안됨)
        for (int i = 0; i <= floor; i++) {
            for (int j = 0; j <= room; j++) {
                memo[i][j] = -1;
            }
        }

        return recur(floor, room);
    }

    private static int recur(int k, int n) {
        // 베이스 케이스 1: 0층은 n명
        if (k == 0) {
            return n;
        }

        // 베이스 케이스 2: 모든 층의 1호는 1명
        if (n == 1) {
            return 1;
        }

        // 메모이제이션: 이미 계산된 값이 있으면 반환
        if (memo[k][n] != -1) {
            return memo[k][n];
        }

        // 점화식: dp[k][n] = dp[k][n-1] + dp[k-1][n]
        // 재귀 호출로 필요한 값들을 계산
        memo[k][n] = recur(k, n - 1) + recur(k - 1, n);

        return memo[k][n];
    }
}
